{
  "title": "C++",
  "content": "C++ (/ˈsiː plʌs plʌs/, telaffuz: si pılas pılas), Bjarne Stroustrup tarafından 1979 yılında Bell Laboratuvarları'nda geliştirilmeye başlanmış, C'yi kapsayan ve çok paradigmalı, yaygın olarak kullanılan, genel amaçlı bir programlama dilidir.\nİlk olarak C With Classes (Sınıflarla C) olarak adlandırılmış, 1983 yılında ismi C++ olarak değiştirilmiştir. Günüzümüzde en çok kullanılan programlama dillerinden biri olmuştur.\nC++ tasarlanırken C programlama dili ile olabildiğince uyumlu olması göz önüne bulundurulmuş ve K&R2'deki tüm örnek kodun derleneceği şekilde tasarlanmıştır.\nC++, C'nin sağladığı alt seviye sıkı donanım desteğinin yanında farklı veri türleri, sınıf, template, sıradışı durum yönetimi, isim alanı (namespace), işleç fazladan yüklemesi, işlev fazladan yüklemesi, referans, hafıza yönetimi ve pek çok kütüphane imkanı sunar.\n\n\n== Tarihi ==\n1979 senesinde bir Danimarkalı bilgisayar bilimci olan Bjarne Stroustrup, sonradan C++ olarak bilinecek olan \"C with Classes\" üzerinde çalışmaya başladı. Onu yeni bir dil geliştirmeye iten şey, doktora tezini geliştirirkenki programlama deneyimiydi. Stroustrup, Simula'nın büyük yazılımlar geliştirmeye yardımcı olan pek çok özelliğe sahip olduğunu, fakat dilin pratikte kullanım için fazla yavaş kaldığını, BCPL'in ise hızlı ancak büyük yazılımlar geliştirmek için fazla alt-seviye olduğunu fark etti. Stroustrup AT&T Bell Labs'ta çalışmaya başladığında UNIX çekirdeğini dağıtık bir sistem olarak incelemeye başladı. Doktora deneyiminden yola çıkarak, C dilini Simula'nın özellikleriyle zenginleştirmek için yola çıktı. C dili seçildi çünkü genel amaçlı, hızlı, taşınabilir ve zaten yaygın olarak kullanılıyordu.\nBaşlangıçta, Stroustrup'un \"C with Classes\"ı sınıflar, türetilmiş sınıflar, güçlü türleme (strong typing), varsayılan fonksiyon argümanları (default argument) gibi özelliklerini bir C derleyicisi olan CPre'ye eklenmiştir.\n1982'de Stroustrup C with Classes'ı daha da ileri taşıyan, pek çok diğer isimlendirmelerden sonra \"C++\" (++ C'deki artırma operatörüdür) olarak anılan dili geliştirdi. Sanal fonksiyon, fonksiyon adı ve operatör fazladan yüklenmesi, referanslar, sabit oluşturma (constant), tür-güvenli bellek tahsisi (new ve delete kullanarak), geliştirilmiş tür kontrolü, BCPL'deki gibi iki slash karakteriyle yapılan tek satırlık yorumlar (//) eklenen özellikler arasındaydı. Dahası, Stroustrup, C++ için yeni bir derleyici olan Cfront'u geliştirdi.\n1984'te, Stroustrup ilk giriş/çıkış kütüphanesini gerçekledi. Bir isimli fonksiyon yerine çıkış operatörünün (<<) sağlanması fikri Doug McIlroy tarafından önerilmiştir (McIlroy öncesinde Unix pipe'larını öneren kişidir).\n1985'te The C++ Programming Language'in ilk baskısı yapılmış ve henüz resmi bir standard olmadığından bu kitap bir kesin referans olarak kabul edilmiştir. C++'ın ilk ticari gerçeklenimi aynı yılın ekim ayında yayınlanmıştır.\n1989'da C++ 2.0 yayınlandı ve 1991'de The C++ Programming Language kitabının güncellenmiş ikinci baskısı yapıldı. C++ 2.0 ile çoklu kalıtım, soyut sınıflar, statik üye fonksiyon, const üye fonksiyonlar ve protected üyeler eklenmiştir. 1990'da The Annotated C++ Reference Manual yayınlandı. Bu kitap, gelecekte yayınlanacak olan resmi standard için bir taban teşkil etmiştir. Sonrasında eklenen özellikler, template, sıradışı durum yönetimi, isim alanları, yeni isimli castlar (tür dönüştürme) ve bool veri türüdür.\n1998'de C++98 yayınlandı ve dilin standardlaştırılması başladı. 2003'te küçük bir güncelleme olan C++03 yayınlandı.\nC++98 sonrasında C++'ın evrimi 2011'e kadar görece yavaş ilerlemiştir. 2011'de C++11 yayınlandı. C++11 ile standard kütüphane genişlemiş ve C++ programcılarının faydalanacağı pek çok özellik eklenmiştir. Bir başka küçük güncelleme olan C++14 Aralık 2014'te yayınlandı. C++17 daha büyük bir güncellemedir ve Aralık 2017'de yayınlanmıştır. Şubat 2020'de tasarısı sonlandırılan  C++20 standardı 4 Eylül 2020 onaylanmış ve resmi olarak 15 Aralık 2020 basılmıştır.\nStroustrup, 3 Ocak 2018'de \"C++ programlama dilini kavramsallaştırması ve geliştirmesi\" nedeniyle Charles Stark Draper Prize mühendislik ödülünün 2018 yılı kazananı olarak duyurulmuştur.\n(Aralık 2022 (2022-Aralık) itibarıyla) C++ TIOBE index'te Java'yı TIOBE sıralamasındaki tarihinde ilk kez geride bırakmış Python ve C programlama dillerinin ardından üçüncü sırada listelenmiştir.\n\n\n=== Etimoloji ===\nStroustrup'a göre, \"isim C dilinden yapılan değişimlerin evrimsel doğasını vurguluyor.\"\nİsimlendirme Rick Mascitti tarafından (1983'ün ortalarında) yapılmıştır ve ilk defa Aralık 1983'te kullanılmıştır. Mascitti'ye bununla ilgili soru yöneltiğinde (1992'de), mizah amaçlı bu ismin verildiğini belirtmiştir. İsimlendirme C'nin ++ operatöründen (eklendiği değişkenin değerini artırır) gelir ve \"+\" geliştirilmiş bilgisayar programlarını ifade etmede kullanılan yaygın bir isimlendirme geleneğidir.\nC++'ın geliştirilmesi sürecinde, dil son adını almadan evvel, \"new C\" ve \"C with Classes\" diye anıldığı da olmuştur.\n\n\n=== Felsefe ===\nC++'ın yaşamı boyunca geliştirilmesi ve evrimi bir dizi ilkeye dayandırılmıştır:\n\nGerçek sorunlara göre yönlendirilmeli ve özellikleri gerçek programlarda hemen faydalı olmalıdır.\nHer özellik (makul derecede açık bir yöntemle) gerçeklenebilir olmalıdır.\nProgramcılar kendi programlama stillerini seçme özgürlüğüne sahip olmalıdır ve bu stil C++ tarafından tam olarak desteklenmelidir.\nFaydalı olacak bir özelliğe izin vermek, C++'ın her türlü yanlış kullanımını engellemekten daha önemlidir.\nProgramları, ayrı, iyi tanımlanmış parçalar şeklinde organize edilmesini sağlayacak imkanlar sunmalı ve bu ayrı geliştirilen parçaların birleştirilmesini mümkün kılmalıdır.\nTür sisteminin örtük (implicit) ihlallerine izin verilmemelidir (ancak programcı tarafından kasıtlı (explicit) olarak talep edilen ihlallere izin verilir).\nKullanıcı tarafından oluşturulan türler, yerleşik türlerle aynı destek ve performansa sahip olmalıdır.\nKullanılmayan özellikler, oluşturulan yürütülebilir dosyaları olumsuz etkilememelidir (örneğin daha düşük performansa neden olmamalıdır).\nC++'ın altında  bir başka dil olmamalıdır (assembly dili haricinde).\nC++, kendi ayrı ve uyumsuz programlama ortamını teşvik etmek yerine, mevcut diğer programlama dilleriyle uyumlu çalışabilmelidir.\nProgramcının niyeti bilinmiyorsa, programcıya manuel kontrol sağlayarak bunu belirtme imkanı verilmelidir.\n\n\n=== Standardizasyon ===\n\nBir programlama dilini oluşturan gramer, anlam ve standard kütüphane yapıları muğlak olmayacak bir biçimde belgelenir (spec veya specification) ve yayınlanır. Derleyici sağlayıcıları bu belgeyi kullanarak dili gerçekleyen derleyiciyi oluşturur.\nC++ dilinin özelliklerini belirleyen bu belge (buradan sonrasında, standard) ISO / IEC Ortak Teknik Komitesi 1 (İng: Joint Technical Committee 1, JTC1) / Altkomite 22 (Subcommittee 22, SC22) Çalışma Grubu 21 (Working Group 21, WG21) (ISO/IEC JTC1/SC22/WG21) tarafından geliştirilir.\nİlk standard 1998'de ISO/IEC 14882:1998 adıyla yayınlandı. Sonrasında C++03, C++11, C++14, C++17, C++20 ve mevcut standard olan C++23 yayınlandı. 2012 sonrası üçer senelik periyotlarla yayınlanmaya başlanmıştır.\n\n\n== Dil ==\nC++ dili iki temel bileşenden oluşur: C'den devraldığı yapılarla donanım özellikleriyle doğrudan eşleşme ve bu eşleşmeler üzerine kurulmuş maliyetsiz soyutlamalar (zero-overhead abstractions). Stroustrup C++'ı şu şekilde açıklamıştır: \"etkili kullanım ve elegan soyutlamalar için [tasarlanmış] bir hafif soyutlama programlama dili\" ve \"hem donanım erişimi ve hem de soyutlama desteği C++'ın temelidir. Onu diğer dillerden ayıran, bunu etkili bir biçimde yapmasıdır.\"\n\n\n=== Nesne saklama ===\nC++, C'de olduğu gibi, dört farklı bellek yönetimine sahiptir: otomatik saklama süresince barındırılan nesneler, statik saklama süresince barındırılan nesneler, dinamik saklama süresince barındıran nesneler ve thread'te saklama süresince barındırılan nesneler.\n\n\n==== Otomatik saklama süresince barındırılan nesneler ====\nBir fonksiyon veya kapsamda (scope) tanımlanan nesneler bir stack veri yapısında tutulur. Buna göre, bir kapsama girildiğinde ({) nesnelerin tanımlanma sırasına göre yapıcı üye fonksiyon (constructor) çağrılır, kapsam terk edildiğinde (}) nesne yaşam süresinin sonuna gelinir ve tanımlanma sırasının tersi yönünde yok edici üye fonksiyon (destructor) çağrılır (RAII). En son tanımlanan en önce yok edilir (son giren ilk çıkar).\n\n\n==== Statik saklama süresince barındırılan nesneler ====\nStatik saklama sürecine sahip nesneler kapsamdan bağımsız olarak program süresince saklanır ve main() fonksiyonu çağrılmadan oluşturulup, main() bitiminden sonra tanımlanma sırasının tersi yönünde yok edilir.\n\n\n==== Dinamik saklama süresince barındırılan nesneler ====\nDinamik saklama sürecine sahip nesneler new çağrısıyla oluşturulur ve delete çağrısıyla yok edilir. new çağrısı tahsis edilmiş bellek alanı döndürür. C++ Core Guidelines, new ve delete yerine, tekil kaynak sahipliği için make_unique<T>, paylaşılmış kaynak sahipliği için make_shared<T> çağrılarıyla oluşturabilecek zeki işaretçilerin (smart pointer) kullanılmasını tavsiye eder.\n\n\n==== Thread saklama süresince barındırılan nesneler ====\nThread saklama sürecine sahip nesneler thread_local anahtar sözcüğüyle oluşturulur ve statik saklama sürecine oldukça benzer. Temel fark, nesnelerin oluşturulması thread oluşturulmasından öncedir ve yok edilmesi thread çalışmasının bitimiyle (join) olur.\n\n\n=== Template ===\nTemplate (Türkçe: şablon) yapısı türden bağımsız derleme zamanında parameterize değişken, fonksiyon veya sınıf yazılmasına izin verir ve jenerik programlamayı, parametrik türün oluşturulmasından önce (type instantiation) tür manipulasyonuna izin veren template metaprogramlamayı ve kod optimizasyonunu mümkün kılar. Template mekanizması Turing-tam'dır, böylece herhangi bir hesaplamanın bir şekilde derleme zamanında programlanarak ifade edilebilmesini sağlar. Template'e geçilen parametre bir tür (type) ve türün nesnesi (non-type) olabilir.\n\n\n=== Nesne ===\nC++, nesne tanımlamada RAII(Resource Acquisition Is Initialization) tekniğini kullanır. Nesne için gerekli olan kaynak ayrımı (Resource Acquisition), tanımlandığı anda yapılır (Initialization) ve gerektiğinde deterministik olarak serbest bırakılır. Böylece kaynaklar init()/destroy(), allocate()/free(), open()/close() gibi fonksiyon çiftleriyle manuel olarak yönetilmek zorunda kalmaz.\n\n\n==== Kapsülleme ====\nKapsülleme (encapsulation), veri yapısının geliştirici tarafından doğru bir şekilde kullanılacağından emin olmak için nesneye ait bilgilerin bir kısmını erişilemez yapmaktır. C++, sınıf yapısında üyelerin public, protected veya private tanımlanmasına izin verir. private üyeler yalnızca sınıfın üyeleri tarafından erişilebilir, böylece sınıfın kendisini ilgilendiren bazı üye değişken veya fonksiyonlar kullanıcıdan (client) saklanır. Ayrıca bu yolla nesnenin yaşamı süresince değişmemesi gereken durumlar (class invariant) korunabilir.\n\n\n==== Kalıtlama ====\nKalıtlama (inheritence) var olan bir türün özelliklerini taşıyan yeni bir tür oluşturmayı sağlar. Temel sınıftan kalıtım, \"public\", \"protected\" veya \"private\" olarak ilan edilebilir. Diğer iki kalıtım türü arayüzün anlaşılmasını zorlaştırdığından çoğu zaman yalnızca public kalıtım kullanılır. Geçiş belirteci belirtilmezse, class private, struct public olarak kalıtılır.\nTemel sınıftan kalıtım sanal (virtual) olarak ilan edilebilir, buna sanal kalıtım (virtual inheritence) denir. Sanal kalıtım çoklu kalıtımın problemlerinden sıyrılarak temel sınıfın yalnızca bir örneğinin kalıtım grafiğinde olmasını sağlar.\n\n\n=== İşleçlerin ve işlevlerin fazladan yüklenmesi ===\nC++ dilinde işleçlerin (operator) çoğu fazladan yükleme yoluyla genelleştirilebilir. Örneğin + işleci sayılar için anlamlıyken, std::string sınıfı için de fazladan yüklenmiş, böylece türün temsil ettiği veriye + işleciyle birleştirilme yeteneği kazandırılmıştır. Benzer şekilde iki std::string sınıfı nesnesinin eşitliği == işleciyle kontrol edilebilir. Kullanıcı tanımlı herhangi bir tür (sınıf), işleçleri fazladan yükleyebilir.\nAynı isme sahip işlevler (function) farklı tür veya sayıda parametre alarak fazladan yüklenebilir. Örneğin std::to_string fonksiyonu int, float ve double türleri için fazladan yüklenmiştir.\n\n\n=== Çokbiçimlilik ===\nÇokbiçimlilik (polymorphism) kullanılarak farklı türler aynı arayüz üzerinden erişilebilir. Çokbiçimli bir tür kendisini oluşturan diğer türler gibi davranabilir. C++, dinamik (çalışma zamanında) ve statik (derleme zamanında) çokbiçimlilik çeşitlerine izin verir.\n\n\n==== Dinamik çokbiçimlilik ====\n\n\n===== Kalıtlama kullanılarak =====\nÜst sınıfa işaret eden bir pointer veya ona ait bir referans, alt sınıfları da gösterebilir.\nBu durumda üst sınıf bir çokbiçimli türdür (polymorphic type). Eğer üst sınıf bir fonksiyona referans veya pointer şeklinde parametre olarak geçilirse, ondan türetilmiş sınıflar da geçilebilir. Üst sınıf üzerinden alt sınıfların üyeleri kullanılabilir. Alt sınıflardan hangisinin geçildiği dynamic_cast kullanılarak belirlenebilir.\n\n\n===== Sanal üye fonksiyonlar kullanarak =====\nTüretilmiş sınıf, üst sınıfta sanal (virtual) olarak işaretlenmiş bir üye fonksiyonun içeriğini değiştirerek\ntekrar gerçekleyebilir (override). Bu durumda çokbiçimli tür, tekrar gerçeklenen üye fonksiyonu çağıracaktır.\n\n\n==== Statik çokbiçimlilik ====\nTemplate yapısı farklı türler için parçalı veya tam özelleştirilerek parametrik çokbiçimlilik sağlanabilir.\nİşlevlerin fazladan yüklenmesi de statik çokbiçimlilik olarak düşünülebilir. Aynı isme sahip fonksiyonlar, parametre türü veya sayısına göre farklı fonksiyonları çağırır.\n\n\n=== Lambda ifadeleri ===\nC++ lambda ifadeleriyle anonim fonksiyon yazımını destekler. \n\ndönüş_tipi düşürülebilir, bu durumda dönüş tipi gövdeden çıkarımsanır:\n\nLambda parametre almıyorsa, () yapısı düşürülebilir:\n\nLambda değişkene atanarak isim alabilir ve tekrar kullanılabilir:\n\nLambda tanımlandığı anda çalıştırılıp hesaplama sonucuna erişilebilir:\n\nC++20 ile template lambda ifadeleri yazılabilir:\n\n\n=== Sıradışı durum yönetimi ===\nProgram çalışırken yolunda gitmeyen bir şey oluştuğunda ve programın aniden sonlandırılması arzu edilmiyorsa, sıradışı durum yönetimi (exception handling) kullanılarak ana koddan ayrı olarak yönetim sağlanabilir. Sıradışı durum (exception) oluştuğu yerde bir hata kodu fırlatır ve sıradışı durum yöneticisi (exception handler) tarafından yakalanana kadar kapsam dışana taşar. Eğer hata kodu yakalanmazsa program sonlandırılır.\n\n\n== Standard Kütüphane ==\n\nC++ standard kütüphanesi, pek çok tutucu tür, algoritma, G/Ç, dosya sistemi, string, regex, multithread, metaprogramlama araçları, hafıza yönetimi, zaman yönetimi, sıradışı durum yönetimi, çeşitli matematik fonksiyonları, rastgele sayı üreteci, C ile geriye dönük uyumluluk başlık dosyaları bulundurur.\n\n\n== C++ Core Guidelines ==\nC++ Core Guidelines (Türkçe, C++ Temel Yönelgeleri), C++ programcılarının daha basit, daha etkili, daha yönetilebilir kod yazmalarını sağlamayı hedefleyen yönelgeleri içeren bir projedir. Projenin editörlüğünü dilin yaratıcısı Bjarne Stroustrup ile ISO C++ Çalışma Grubu başkanı Herb Sutter sürdürür.\nCore guidelines pek çok stil, iyi uygulama ve modern C++ tavsiyeleri bulundurur. Statik analiz araçları bu tavsiyeleri gerçekleyerek kod yazılırken programcıları kötü uygulamalardan kaçınmasına yardımcı olur.\nGuideline Support Library (GSL), Core Guidelines'ta tavsiye edilen pek çok tür ve fonksiyonu barındıran bir kütüphanedir.\n\n\n== Derleme modeli ==\nC++ çoğunlukla derlenen bir dil olarak gerçeklenmiştir. Kaynak kodun derlenme süreci dört aşamadan oluşur, sırasıyla; önişleme, derleme, assembly ve bağlama. Derleyici kaynak koda uygulandığında bu aşamalar birbiri ardına gerçekleşir.\n\nÖnişlemci (preprocessor) #include direktifiyle eklenen dosyaları koda taşır. Ayrıca kodda sözcük değişiklikleri yapabilir, koşullu derleme sağlayabilir, derleyicinin bir takım özelliklerini kontrol edebilir veya kodun derleneceği platform hakkında bilgi alabilir.\nDerleyici (compiler veya compiler proper) kodu tarar, parçalara ayırır, sözdizimi ve anlamı analiz eder, hataları bildirir, optimize eder ve işlemcinin sahip olduğu mimarinin assembly koduna derler.\nAssembly kodu assembler tarafından yerdeğiştirebilir (relocatable object code) hedef koduna dönüştürülür.\nBağlayıcı (linker) yerdeğiştirebilir hedef kodunu diğer hedef kodlarına (geliştirilen veya önceden derlenmiş sistem kütüphanleri vd.) bağlar ve çalıştırılabilir hedef kodunu oluşturur.\n\n\n== Örnekler ==\n\n\n=== Değişkenler ===\nDeğişkenlerin bir programda çalıştırmak için değişkenlerin veri türünü belirtmek gereklidir (örneğin, int , char, double, bool, std::string) ancak C++11'de auto anahtar kelimesi eklendiği için değişkenin veri türünü belirtmek gerek yoktur. \n\n\n=== Yorum Satırları ===\nYorum satırları derleyici tarafından çalıştırılmaz. Bunlar kodun anlaşılmasını kolaylaştırmak için eklenir.\n\n\n=== Merhaba Dünya ===\n\nBu program uçbirim ekranına \"Merhaba, dunya!\" yazacaktır. \n\n\n=== İşleçlerinin fazladan yüklenmesi ===\n\n\n=== Lambda ifadeleri ===\n\n\n=== Sıradışı durum yönetimi ===\n\n\n== Ayrıca bakınız ==\nC tabanlı programlama dilleri listesi\n\n\n== Kaynakça ==\n\n\n== Dış bağlantılar ==\n\nStandart C++'ı Yeni Bir Dil Olarak Öğrenmek8 Nisan 2014 tarihinde Wayback Machine sitesinde arşivlendi.-Bjarne Stroustrup'un yazısının çevirisi\nC++ reference 1 Mart 2024 tarihinde Wayback Machine sitesinde arşivlendi. (İngilizce)\nCplusplus.com1 Mart 2024 tarihinde Wayback Machine sitesinde arşivlendi. (İngilizce)\nC++ Super-FAQ1 Mart 2024 tarihinde Wayback Machine sitesinde arşivlendi. (İngilizce)\nC++ Language Reference 1 Mart 2024 tarihinde Wayback Machine sitesinde arşivlendi. (İngilizce)\nHacking C++ — Çağdaş C++ Öğrenin 15 Şubat 2024 tarihinde Wayback Machine sitesinde arşivlendi. (İngilizce)"
}